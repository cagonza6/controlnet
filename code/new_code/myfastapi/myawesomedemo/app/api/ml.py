import os
import shutil
import tempfile
import logging
from pathlib import Path
from typing import List, Any
import yaml

import numpy as np

from matplotlib import pyplot as plt

from awesomer_demo import process, load_model, modelconfig_path, ckpt_path

logger = logging.getLogger("myawesomedemo")

model = None
if model is None:
    logger.info("Loading model, this instance wil be reused.")
    model = load_model(modelconfig_path, ckpt_path)


def build_names(n_files: int, extension: str) -> list:
    """Generate a list of 'n_files'-filenames for generated images with the form
    img_gen_X, where x is an integer number. These are the files expected to be
    generated by model. It automatically includes the detected map file as part
    of the set.

    :param n_files: number of names to generate.
    :param extension:
    :return: list
    """

    n_digits = len(str(n_files)) + 1
    base_name = "img_gen_{}" + extension
    r_names = [base_name.format(str(i+1).zfill(n_digits)) for i in range(n_files)]
    gen_names = ["detected_map" + extension] + r_names

    logger.info("Built names for [{}] files".format(n_files))
    return gen_names


async def compress(gen_images: List[np.ndarray],
                   gen_names: List[str],
                   params: dict,
                   target_filename: str) -> None:
    """Generates a compressed file with the name in 'target_file' an ensures
    zip extension. This function uses 'shutil.make_archive', which means it
    would work mostly on linux based systems.
    The file is generated in a temporary folder by:
        1. Generate temporary folder
        2. Store each image with the given name under the folder in 1.
        3. Compress the folder using 'shutil.make_archive' in the given path
           'target_filename'
        4. exit. This destroyed the temporary folder.


    :param gen_images: generated images by the model.
    :param gen_names: generated names for the images, same length as gen_images.
    :param params: request parameters used to generate the images
    :param target_filename: name of ZIP file to generate
    :return: None
    """
    logger.info("Starting compression of files")
    # Remove extension, 'shutil.make_archive' adds it
    shorten = target_filename.lower().endswith(".zip")
    _target_name = target_filename[:-4] if shorten else target_filename

    with tempfile.TemporaryDirectory() as temp_f:
        temp_dir = Path(temp_f)
        results_folder = temp_dir / "results"
        results_folder.mkdir(parents=True, exist_ok=True)

        dict2yaml(params, results_folder / "process_parameters.yaml")

        for image, name in zip(gen_images, gen_names):
            plt.imsave(results_folder / name, image, format="png")

        logger.info("Starting compression of images.")
        shutil.make_archive(_target_name, "zip", results_folder)
        logger.info("Compressed images at: {}".format(_target_name))


async def generate_images(trained_model: Any,  # many possible, just one expected as of now
                          image: np.ndarray,
                          params: dict
                          ) -> List[np.ndarray]:
    """Main routine to generate the images, it takes the model, given image and
    calls the process function.

    :param trained_model: pytorch model to use. In this case 'ControlLDM' is expected
    :param image: numpy
    :param params: dict containing the parameters for the model to process.
    :return: list of numpy arrays containing the generated images
    """

    logger.info("Starting model process")
    gen_images = process(trained_model, input_image=image, **params)
    logger.info("Generation finished")
    return gen_images


def dict2yaml(params, file_path):
    logger.info("Dumping configuration parameters {}".format(file_path))

    """Stores the given dictionary

    :param params:
    :param file_path:
    :return:
    """
    with open(file_path, 'w') as f:
        yaml.dump(params, f)


def cleanup_file(f_path: Path) -> None:
    logger.info("Removing File {}".format(f_path))
    """removes the given file by using the OS library

    :param f_path: file to remove
    """
    os.remove(f_path)
